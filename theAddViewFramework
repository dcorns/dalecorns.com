This document describes the architecture of this website. It describes how easy it is to build, maintain and scale using, for now, what I call the addView Framework.
In a nutshell, every view is a site unto itself and completely self contained. Keep things small like this makes the site more scalable and maintainable and it makes the more of the code reusable. Not only that, but one could poor in large amount of code into one component if they wanted to do so, but what would be the point. And lets define component. A component has at least one file and possibly three. It will have at the least an html file and optionally a style sheet and a javascript file. For anything more than trivial, all three file will be used.
This architecture relies on build tools to combine all the files for production into one file for each of the component file types. Except, of course for the index.html file. Additional file can be added to the single file compilations that may not be part of a component, for example, layout.css and a theme.css. These files will typically be used for files that are used site wide. Here it is important that the components are not dependent on anything, but their three files, but for gluing everything together additional files that are not part of the components may be used.
Component Architecture: Components are related by their file names. For example: aboutMe.html, aboutMe.js, and aboutMe.css would make up the aboutMe component. In the case of html and js the file names are used by addView to build thing. The aboutMe.css is called that for organizational purposes and could just as easily be called aboutMe.scss or .sass. All of the styling code winds up in one css file in the end and it is a naming convention inside the css that actually associates the style to the html. The convention is to use the to use the html file name as an id prefix on all the css that is to be styled inside it. And for this to work, of coarse, each html view will be wrapped in an element with an id that matches the file name. Usually that element will be the section element. In summary, a component consists of a html view file with an element wrapper that matches the file name, a styling file that name space all the styles with the id that matches the html file name that it is to style, and a java script file that hase the same name as the html file except for the extension 'js' instead of 'html'.
That is all there is to building the views, functionality and style for the application. You can see how easy this will make testing and making changes to the application. As for scaling the application up, one only break the component up into groups that are loaded when needed. The only thing that must be loaded when the application first loads in the index.html that will contain the application, its styles and the js containing the logic that ties everything together.
This next section describes that logic and how these components are processed to produce an application that is however large and complex as is desired, all based on these simple connections and file management.
The build steps: The first build step needed is to convert all the views to javaScript objects using grunt addView. Addview will return a JS file that exports all the views in a master view object. Each view object is given the property name of the html file name from which it was generated. By setting the output of the view object file to a directory that will be proccessed by webpack or whatever else you want to use for combining the java script, the view object file will be combined along with the rest of the code and that is the next step in the build process; using webkit or prefered combiner of JS files. All your styles can be combined using sass or as is the case here postcss. Again however you want to combine the styles is up to you. After building we will have one JS file and one CSS file. These are the files that we will link up in our index.html page. Our style sheet called at the top and our JS called at the bottom.
Now that the build process is covered lets talk about what is the basic functionality that every web application needs and how that is implemented in this architecture.
Routing: Routing in this architecture handles the loading of the view and runs its related script, if one exists. Since styling is name spaced, it is already present in main.css if given. It is processed during the build. The client side routing is handled by the viewRouter module.
viewRouter: When requiring viewRouter 3 parameters are passed. The first is a view object which contains the all the html for the views. It is created by grunt-addView. It has a property name that matches each view name and each property value contains the html for the view. The Second parameter is the viewScript object which contains a property matching each view name for which there is a script. The property values are require statements that point to the script module for the respective view. Lastly, the third parameter is for adding the routing to a parent object. Armed with this data, the viewRouter returns the loadRoute function. It is the loadRoute function that actually does all the work.
loadRoute: The loadRoute function is what is returned by requiring viewRouter, so I will typically assign the return function to a variable called route which is the loadRoute function. Hence I will refer to the loadRoute function here by its assigned name 'route'. Route takes only two arguments. The first is a hash path of the view to be displayed and the second is the id of the element in which the view is to be displayed. If the second argument is not provided 'main-content' is assumed. This makes it easier for a lot of cases where the views are simply swapped in and out of the same element. It can be given the id of 'main-content' and then only the hash path will need to be provided to route. When a view needs to be placed somewhere else, simply provide the id. When route is called it matches the name of the view in the hash path to the property name in the view Object and the properties value replaces the innerHtml of the element with the id of 'main-content' or with the id matching the id provided as the second parameter. Then the viewScript object is checked for a property name matching the view name and if it exists, its value is invoked passing in the object that was provided as the third parameter when viewRouter was required. This parameter is not always used by the script being invoked, but if it was provided, it will always be passed. That is it for routing. One simple call loads the view where ever and runs the associated script if any. It should be noted here that if any view specific css is required, the view should be wrapped in an element with an id that matches the name of the view. Then the styling can be applied through reference to the view name as an id. It may be a good idea to keep all view specific styling in a separate styling file that matches the name of the view, but it is not required.
In addition to routing the proper views when clicked, a method must also be employed to allowing the user to navigate between the views using the browser navigation buttons. This functionality is provided by the firstDo method which is called on the initial page load. Here we use the window.history object, the location object and the popstate event to properly navigate the views.
It is also nice to have the page return to the same view as the user left it on refresh and upon returning to the page from an external link. This is also setup in firstDo by taking advantage of sessionStorage. That pretty much covers our application navigation.
Data Handling:
Data for the views is access through clientRoutes.js. It returns an object with one function called getData. getData takes three arguments. The first is the path to the data, the second is the callback function to execute when the data is retrieved and the third is a token for authorizing data access. When invoked getData will make an ajax request for the data and, if successful, it will store the data in local storage for offline access and then deliver it to the application via the callback. If the ajax call does not succeed, getData will check for the data in local storage if it is there, it will deliver it via the callback. If it is not in local storage getData will return an error in the callback.